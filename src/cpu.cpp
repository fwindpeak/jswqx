switch (PEEK(reg_pc ++)) {case 0x00:{ reg_pc ++;PUSH(reg_pc >> 8);PUSH(reg_pc & 0xFF);flag_b = 1;PUSH(GET_PS());
//wqx set flag_i here.
flag_i = 1;reg_pc = PEEKW(IRQ_VEC_ADDR);cycles += 7; }break;
case 0x01:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;SET_NZ(reg_a |= LOAD(addr));cycles += 6; }break;
case 0x02:{  }break;
case 0x03:{  }break;
case 0x04:{  }break;
case 0x05:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;SET_NZ(reg_a |= LOAD(addr));cycles += 3; }break;
case 0x06:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 >> 7;STORE(addr, SET_NZ((tmp1 << 1) & 0xFF));cycles += 5; }break;
case 0x07:{  }break;
case 0x08:{ PUSH(GET_PS());cycles += 3; }break;
case 0x09:{ register uint16_t addr = reg_pc;reg_pc ++;SET_NZ(reg_a |= LOAD(addr));cycles += 2; }break;
case 0x0A:{ flag_c = reg_a >> 7;SET_NZ(reg_a = (reg_a << 1) & 0xFF);cycles += 2; }break;
case 0x0B:{  }break;
case 0x0C:{  }break;
case 0x0D:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;SET_NZ(reg_a |= LOAD(addr));cycles += 4; }break;
case 0x0E:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 >> 7;STORE(addr, SET_NZ((tmp1 << 1) & 0xFF));cycles += 6; }break;
case 0x0F:{  }break;
case 0x10:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if (!flag_n) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0x11:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;SET_NZ(reg_a |= LOAD(addr));cycles += 5; }break;
case 0x12:{  }break;
case 0x13:{  }break;
case 0x14:{  }break;
case 0x15:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;SET_NZ(reg_a |= LOAD(addr));cycles += 4; }break;
case 0x16:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 >> 7;STORE(addr, SET_NZ((tmp1 << 1) & 0xFF));cycles += 6; }break;
case 0x17:{  }break;
case 0x18:{ flag_c = 0;cycles += 2; }break;
case 0x19:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;SET_NZ(reg_a |= LOAD(addr));cycles += 4; }break;
case 0x1A:{  }break;
case 0x1B:{  }break;
case 0x1C:{  }break;
case 0x1D:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;SET_NZ(reg_a |= LOAD(addr));cycles += 4; }break;
case 0x1E:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 >> 7;STORE(addr, SET_NZ((tmp1 << 1) & 0xFF));cycles += 6; }break;
case 0x1F:{  }break;
case 0x20:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;reg_pc = (reg_pc - 1) & 0xFFFF;PUSH(reg_pc >> 8);PUSH(reg_pc & 0xFF);reg_pc = addr;cycles += 6; }break;
case 0x21:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;SET_NZ(reg_a &= LOAD(addr));cycles += 6; }break;
case 0x22:{  }break;
case 0x23:{  }break;
case 0x24:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);flag_z = !(reg_a & tmp1) ;flag_n = tmp1 >> 7;flag_v = (tmp1 & 0x40) >> 6;cycles += 3; }break;
case 0x25:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;SET_NZ(reg_a &= LOAD(addr));cycles += 3; }break;
case 0x26:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ(((tmp1 << 1) | flag_c) & 0xFF));flag_c = tmp1 >> 7;cycles += 5; }break;
case 0x27:{  }break;
case 0x28:{ SET_PS(POP());cycles += 4; }break;
case 0x29:{ register uint16_t addr = reg_pc;reg_pc ++;SET_NZ(reg_a &= LOAD(addr));cycles += 2; }break;
case 0x2A:{ register uint8_t tmp1 = reg_a;SET_NZ(reg_a = ((reg_a << 1) | flag_c) & 0xFF);flag_c = tmp1 >> 7;cycles += 2; }break;
case 0x2B:{  }break;
case 0x2C:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);flag_z = !(reg_a & tmp1) ;flag_n = tmp1 >> 7;flag_v = (tmp1 & 0x40) >> 6;cycles += 4; }break;
case 0x2D:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;SET_NZ(reg_a &= LOAD(addr));cycles += 4; }break;
case 0x2E:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ(((tmp1 << 1) | flag_c) & 0xFF));flag_c = tmp1 >> 7;cycles += 6; }break;
case 0x2F:{  }break;
case 0x30:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if ( flag_n) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0x31:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;SET_NZ(reg_a &= LOAD(addr));cycles += 5; }break;
case 0x32:{  }break;
case 0x33:{  }break;
case 0x34:{  }break;
case 0x35:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;SET_NZ(reg_a &= LOAD(addr));cycles += 4; }break;
case 0x36:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ(((tmp1 << 1) | flag_c) & 0xFF));flag_c = tmp1 >> 7;cycles += 6; }break;
case 0x37:{  }break;
case 0x38:{ flag_c = 1;cycles += 2; }break;
case 0x39:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;SET_NZ(reg_a &= LOAD(addr));cycles += 4; }break;
case 0x3A:{  }break;
case 0x3B:{  }break;
case 0x3C:{  }break;
case 0x3D:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;SET_NZ(reg_a &= LOAD(addr));cycles += 4; }break;
case 0x3E:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ(((tmp1 << 1) | flag_c) & 0xFF));flag_c = tmp1 >> 7;cycles += 6; }break;
case 0x3F:{  }break;
case 0x40:{ SET_PS(POP());reg_pc = (POP() | (POP() << 8));cycles += 6; }break;
case 0x41:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;SET_NZ(reg_a ^= LOAD(addr));cycles += 6; }break;
case 0x42:{  }break;
case 0x43:{  }break;
case 0x44:{  }break;
case 0x45:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;SET_NZ(reg_a ^= LOAD(addr));cycles += 3; }break;
case 0x46:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 & 0x01;tmp1 >>= 1;flag_n = 0;flag_z = !tmp1;STORE(addr, tmp1);cycles += 5; }break;
case 0x47:{  }break;
case 0x48:{ PUSH(reg_a);cycles += 3; }break;
case 0x49:{ register uint16_t addr = reg_pc;reg_pc ++;SET_NZ(reg_a ^= LOAD(addr));cycles += 2; }break;
case 0x4A:{ flag_c = reg_a & 0x01;SET_NZ(reg_a >>= 1);cycles += 2; }break;
case 0x4B:{  }break;
case 0x4C:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;reg_pc = addr;cycles += 3; }break;
case 0x4D:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;SET_NZ(reg_a ^= LOAD(addr));cycles += 4; }break;
case 0x4E:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 & 0x01;tmp1 >>= 1;flag_n = 0;flag_z = !tmp1;STORE(addr, tmp1);cycles += 6; }break;
case 0x4F:{  }break;
case 0x50:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if (!flag_v) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0x51:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;SET_NZ(reg_a ^= LOAD(addr));cycles += 5; }break;
case 0x52:{  }break;
case 0x53:{  }break;
case 0x54:{  }break;
case 0x55:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;SET_NZ(reg_a ^= LOAD(addr));cycles += 4; }break;
case 0x56:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 & 0x01;tmp1 >>= 1;flag_n = 0;flag_z = !tmp1;STORE(addr, tmp1);cycles += 6; }break;
case 0x57:{  }break;
case 0x58:{ flag_i = 0;cycles += 2; }break;
case 0x59:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;SET_NZ(reg_a ^= LOAD(addr));cycles += 4; }break;
case 0x5A:{  }break;
case 0x5B:{  }break;
case 0x5C:{  }break;
case 0x5D:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;SET_NZ(reg_a ^= LOAD(addr));cycles += 4; }break;
case 0x5E:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);flag_c = tmp1 & 0x01;tmp1 >>= 1;flag_n = 0;flag_z = !tmp1;STORE(addr, tmp1);cycles += 6; }break;
case 0x5F:{  }break;
case 0x60:{ reg_pc = ((POP() | (POP() << 8)) + 1) & 0xFFFF;cycles += 6; }break;
case 0x61:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 6; }break;
case 0x62:{  }break;
case 0x63:{  }break;
case 0x64:{  }break;
case 0x65:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 3; }break;
case 0x66:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ((tmp1 >> 1) | (flag_c << 7)));flag_c = tmp1 & 0x01;cycles += 5; }break;
case 0x67:{  }break;
case 0x68:{ SET_NZ(reg_a = POP());cycles += 4; }break;
case 0x69:{ register uint16_t addr = reg_pc;reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 2; }break;
case 0x6A:{ register uint8_t tmp1 = reg_a;SET_NZ(reg_a = (reg_a >> 1) | (flag_c << 7));flag_c = tmp1 & 0x01;cycles += 2; }break;
case 0x6B:{  }break;
case 0x6C:{ register uint16_t addr = PEEKW(PEEKW(reg_pc));reg_pc += 2;reg_pc = addr;cycles += 6; }break;
case 0x6D:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0x6E:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ((tmp1 >> 1) | (flag_c << 7)));flag_c = tmp1 & 0x01;cycles += 6; }break;
case 0x6F:{  }break;
case 0x70:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if ( flag_v) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0x71:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 5; }break;
case 0x72:{  }break;
case 0x73:{  }break;
case 0x74:{  }break;
case 0x75:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0x76:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ((tmp1 >> 1) | (flag_c << 7)));flag_c = tmp1 & 0x01;cycles += 6; }break;
case 0x77:{  }break;
case 0x78:{ flag_i = 1;cycles += 2; }break;
case 0x79:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0x7A:{  }break;
case 0x7B:{  }break;
case 0x7C:{  }break;
case 0x7D:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a + tmp1 + flag_c;flag_c = tmp2 > 0xFF;flag_v = (reg_a ^ tmp1 ^ 0x80) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0x7E:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);STORE(addr, SET_NZ((tmp1 >> 1) | (flag_c << 7)));flag_c = tmp1 & 0x01;cycles += 6; }break;
case 0x7F:{  }break;
case 0x80:{  }break;
case 0x81:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;STORE(addr, reg_a);cycles += 6; }break;
case 0x82:{  }break;
case 0x83:{  }break;
case 0x84:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;STORE(addr, reg_y);cycles += 3; }break;
case 0x85:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;STORE(addr, reg_a);cycles += 3; }break;
case 0x86:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;STORE(addr, reg_x);cycles += 3; }break;
case 0x87:{  }break;
case 0x88:{ SET_NZ(reg_y = (reg_y - 1) & 0xFF);cycles += 2; }break;
case 0x89:{  }break;
case 0x8A:{ SET_NZ(reg_a = reg_x);cycles += 2; }break;
case 0x8B:{  }break;
case 0x8C:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;STORE(addr, reg_y);cycles += 4; }break;
case 0x8D:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;STORE(addr, reg_a);cycles += 4; }break;
case 0x8E:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;STORE(addr, reg_x);cycles += 4; }break;
case 0x8F:{  }break;
case 0x90:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if (!flag_c) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0x91:{ register uint16_t addr = PEEKW(PEEK(reg_pc));addr += reg_y;reg_pc ++;STORE(addr, reg_a);cycles += 6; }break;
case 0x92:{  }break;
case 0x93:{  }break;
case 0x94:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;STORE(addr, reg_y);cycles += 4; }break;
case 0x95:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;STORE(addr, reg_a);cycles += 4; }break;
case 0x96:{ register uint16_t addr = (PEEK(reg_pc) + reg_y) & 0xFF;reg_pc ++;STORE(addr, reg_x);cycles += 4; }break;
case 0x97:{  }break;
case 0x98:{ SET_NZ(reg_a = reg_y);cycles += 2; }break;
case 0x99:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_y;reg_pc += 2;STORE(addr, reg_a);cycles += 5; }break;
case 0x9A:{ reg_sp_ = reg_x;cycles += 2; }break;
case 0x9B:{  }break;
case 0x9C:{  }break;
case 0x9D:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;STORE(addr, reg_a);cycles += 5; }break;
case 0x9E:{  }break;
case 0x9F:{  }break;
case 0xA0:{ register uint16_t addr = reg_pc;reg_pc ++;SET_NZ(reg_y = LOAD(addr));cycles += 2; }break;
case 0xA1:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;SET_NZ(reg_a = LOAD(addr));cycles += 6; }break;
case 0xA2:{ register uint16_t addr = reg_pc;reg_pc ++;SET_NZ(reg_x = LOAD(addr));cycles += 2; }break;
case 0xA3:{  }break;
case 0xA4:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;SET_NZ(reg_y = LOAD(addr));cycles += 3; }break;
case 0xA5:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;SET_NZ(reg_a = LOAD(addr));cycles += 3; }break;
case 0xA6:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;SET_NZ(reg_x = LOAD(addr));cycles += 3; }break;
case 0xA7:{  }break;
case 0xA8:{ SET_NZ(reg_y = reg_a);cycles += 2; }break;
case 0xA9:{ register uint16_t addr = reg_pc;reg_pc ++;SET_NZ(reg_a = LOAD(addr));cycles += 2; }break;
case 0xAA:{ SET_NZ(reg_x = reg_a);cycles += 2; }break;
case 0xAB:{  }break;
case 0xAC:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;SET_NZ(reg_y = LOAD(addr));cycles += 4; }break;
case 0xAD:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;SET_NZ(reg_a = LOAD(addr));cycles += 4; }break;
case 0xAE:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;SET_NZ(reg_x = LOAD(addr));cycles += 4; }break;
case 0xAF:{  }break;
case 0xB0:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if ( flag_c) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0xB1:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;SET_NZ(reg_a = LOAD(addr));cycles += 5; }break;
case 0xB2:{  }break;
case 0xB3:{  }break;
case 0xB4:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;SET_NZ(reg_y = LOAD(addr));cycles += 4; }break;
case 0xB5:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;SET_NZ(reg_a = LOAD(addr));cycles += 4; }break;
case 0xB6:{ register uint16_t addr = (PEEK(reg_pc) + reg_y) & 0xFF;reg_pc ++;SET_NZ(reg_x = LOAD(addr));cycles += 4; }break;
case 0xB7:{  }break;
case 0xB8:{ flag_v = 0;cycles += 2; }break;
case 0xB9:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;SET_NZ(reg_a = LOAD(addr));cycles += 4; }break;
case 0xBA:{ SET_NZ(reg_x = reg_sp_);cycles += 2; }break;
case 0xBB:{  }break;
case 0xBC:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;SET_NZ(reg_y = LOAD(addr));cycles += 4; }break;
case 0xBD:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;SET_NZ(reg_a = LOAD(addr));cycles += 4; }break;
case 0xBE:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;SET_NZ(reg_x = LOAD(addr));cycles += 4; }break;
case 0xBF:{  }break;
case 0xC0:{ register uint16_t addr = reg_pc;reg_pc ++;register int16_t tmp1 = reg_y - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 2; }break;
case 0xC1:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 6; }break;
case 0xC2:{  }break;
case 0xC3:{  }break;
case 0xC4:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register int16_t tmp1 = reg_y - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 3; }break;
case 0xC5:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 3; }break;
case 0xC6:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;STORE(addr, SET_NZ((LOAD(addr) - 1) & 0xFF));cycles += 5; }break;
case 0xC7:{  }break;
case 0xC8:{ SET_NZ(reg_y = (reg_y + 1) & 0xFF);cycles += 2; }break;
case 0xC9:{ register uint16_t addr = reg_pc;reg_pc ++;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 2; }break;
case 0xCA:{ SET_NZ(reg_x = (reg_x - 1) & 0xFF);cycles += 2; }break;
case 0xCB:{  }break;
case 0xCC:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register int16_t tmp1 = reg_y - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 4; }break;
case 0xCD:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 4; }break;
case 0xCE:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;STORE(addr, SET_NZ((LOAD(addr) - 1) & 0xFF));cycles += 6; }break;
case 0xCF:{  }break;
case 0xD0:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if (!flag_z) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0xD1:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 5; }break;
case 0xD2:{  }break;
case 0xD3:{  }break;
case 0xD4:{  }break;
case 0xD5:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 4; }break;
case 0xD6:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;STORE(addr, SET_NZ((LOAD(addr) - 1) & 0xFF));cycles += 6; }break;
case 0xD7:{  }break;
case 0xD8:{ flag_d = 0;cycles += 2; }break;
case 0xD9:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 4; }break;
case 0xDA:{  }break;
case 0xDB:{  }break;
case 0xDC:{  }break;
case 0xDD:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;register int16_t tmp1 = reg_a - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 4; }break;
case 0xDE:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;STORE(addr, SET_NZ((LOAD(addr) - 1) & 0xFF));cycles += 6; }break;
case 0xDF:{  }break;
case 0xE0:{ register uint16_t addr = reg_pc;reg_pc ++;register int16_t tmp1 = reg_x - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 2; }break;
case 0xE1:{ register uint16_t addr = PEEKW((PEEK(reg_pc) + reg_x) & 0xFF);reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 6; }break;
case 0xE2:{  }break;
case 0xE3:{  }break;
case 0xE4:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register int16_t tmp1 = reg_x - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 3; }break;
case 0xE5:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 3; }break;
case 0xE6:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;STORE(addr, SET_NZ((LOAD(addr) + 1) & 0xFF));cycles += 5; }break;
case 0xE7:{  }break;
case 0xE8:{ SET_NZ(reg_x = (reg_x + 1) & 0xFF);cycles += 2; }break;
case 0xE9:{ register uint16_t addr = reg_pc;reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 2; }break;
case 0xEA:{ cycles += 2; }break;
case 0xEB:{  }break;
case 0xEC:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register int16_t tmp1 = reg_x - LOAD(addr);flag_c = tmp1 >= 0;SET_NZ(tmp1);cycles += 4; }break;
case 0xED:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0xEE:{ register uint16_t addr = PEEKW(reg_pc);reg_pc += 2;STORE(addr, SET_NZ((LOAD(addr) + 1) & 0xFF));cycles += 6; }break;
case 0xEF:{  }break;
case 0xF0:{ register uint16_t addr = PEEK(reg_pc);reg_pc ++;addr = reg_pc + addr - ((addr & 0x80) << 1);if ( flag_z) { cycles += ((reg_pc ^ addr) & 0xFF00 ? 1 : 2);reg_pc = addr; }cycles += 2; }break;
case 0xF1:{ register uint16_t addr = PEEKW(PEEK(reg_pc));cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 5; }break;
case 0xF2:{  }break;
case 0xF3:{  }break;
case 0xF4:{  }break;
case 0xF5:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0xF6:{ register uint16_t addr = (PEEK(reg_pc) + reg_x) & 0xFF;reg_pc ++;STORE(addr, SET_NZ((LOAD(addr) + 1) & 0xFF));cycles += 6; }break;
case 0xF7:{  }break;
case 0xF8:{ flag_d = 1;cycles += 2; }break;
case 0xF9:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_y) & 0xFF00 ? 1 : 0;addr += reg_y;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0xFA:{  }break;
case 0xFB:{  }break;
case 0xFC:{  }break;
case 0xFD:{ register uint16_t addr = PEEKW(reg_pc);cycles += ((addr & 0xFF) + reg_x) & 0xFF00 ? 1 : 0;addr += reg_x;reg_pc += 2;register uint8_t tmp1 = LOAD(addr);register int16_t tmp2 = reg_a - tmp1 + flag_c - 1;flag_c = tmp2 >= 0;flag_v = (reg_a ^ tmp1) & (reg_a ^ tmp2) & 0x80;SET_NZ(reg_a = tmp2);cycles += 4; }break;
case 0xFE:{ register uint16_t addr = PEEKW(reg_pc);addr += reg_x;reg_pc += 2;STORE(addr, SET_NZ((LOAD(addr) + 1) & 0xFF));cycles += 6; }break;
case 0xFF:{  }break;}